module Perst.Database.DML where

import           Control.Monad.Catch        (MonadMask, finally)
import           Control.Monad.IO.Class     (MonadIO (..))
import           Control.Monad.Trans.Reader (ask)
import           Data.List                  (intercalate)
import           Data.Proxy                 (Proxy (..))
import           Data.Text.Format           (format)
import           Data.Text.Lazy             (Text)
import qualified Data.Text.Lazy             as TL
import           Data.Type.Grec             (fromGrec)
import           Perst.Database.Types


insertText :: (DBOption b, TabConstrB b t, InsConstr b t (Record t))
            => Proxy b -> Proxy t -> Text
insertText pb (pt :: Proxy t) = insertText' pb pt (Proxy :: Proxy (Record t))

insertText' :: (DBOption b, TabConstrB b t, InsConstr b t r)
            => Proxy b -> Proxy t -> Proxy r -> Text
insertText' pb pt pr
  = format "INSERT INTO {}({}) VALUES({})"
    ( tableName pt
    , intercalate "," fns
    , TL.intercalate "," $ zipWith (const $ paramName pb) fns [1..]
    )
 where
  fns = fieldNames' pr

insertMany  :: (MonadIO m, MonadMask m, DBOption b, TabConstrB b t, InsConstr b t r)
            => Proxy t -> [r] -> SessionMonad b m ()
insertMany pt (rs :: [r]) = do
  (pb :: Proxy b, _) <- ask
  (cmd :: PrepCmd b) <- prepareCommand $ insertText' pb pt (Proxy :: Proxy r)
  finally  (mapM_ (runPrepared cmd . fromGrec) rs)
                  (finalizePrepared cmd)

{-
class (TabConstrB b t) => DML (b :: *) (t::DataDef)
  where
    -- | Insert the list of values into database.
    -- Should create Insert-statement with parameters
    -- and execute it for all values in list
    ins ::  Proxy t -> Record t -> SessionMonad b m ()

    -- | In many cases PK should be generated.
    -- There are some possibilities:
    --
    -- * autogenerated PK (Sqlite, MSSQL)
    -- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
    --
    -- In all cases interface is the same.
    -- If we need sequence name (Oracle) we can derive it from table name.
    --
    -- If for backend and table autogeneration of id's is impossible
    -- than empty key-list is returned
    insAuto ::  ( MonadIO m
                , MonadCatch m
                , IsAutoPK rep back kr
                )
                => Proxy '(rep,a) -> [dr] -> SessionMonad back m [kr]
    -- | Simple update by pk. Return list of pk which were updated
    upd ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> [ar] -> SessionMonad back m [kr]
    -- | Delete values by condition.
    -- Count of deleted records is returned
    del ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> Cond rep back (RecordDef a) -> SessionMonad back m Int
    selProj ::  ( MonadIO m
                , MonadCatch m
                , ContainNames (RecordDef a) b
                , Names b
                , RowRepDDL rep back (ProjNames (RecordDef a) b) rr
            )
            => Proxy '(rep,a,b) -> Cond rep back (RecordDef a)
            -> SessionMonad back m [rr]
-}
