{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs                     #-}
{-# LANGUAGE InstanceSigs              #-}
{-# LANGUAGE TemplateHaskell           #-}
{-# LANGUAGE TypeInType                #-}
{-# LANGUAGE UndecidableInstances      #-}
module Perst.Database.Types
  (
  -- * table definition

  DeleteConstraint(..)
  , DataDef(..)
  , TableLike(..)

  -- * backend definition

  , DBOption(..)

  -- * Constraints required for DDL and DML operations

  , TableConstraint
  , TabConstr
  , TabConstrB
  , RecConstr
  , InsConstr
  , InsAutoConstr
  , UpdByKeyConstr
  , DelByKeyConstr

  -- * Non-select Command returns

  -- , CommandType(..)
  -- , ReturnType
  -- , pInsert, pUpdate, pDelete, pDDL

  -- * Singletons type machinery

  , Nullable, NullableSym0, NullableSym1
  , DbTypeName, DbTypeNameSym0, DbTypeNameSym1, DbTypeNameSym2

  -- * Good functions to take table info in runtime

  , tableName, fieldNames, dbTypeNames
  , fieldNames', dbTypeNames'
  , getSymbols, primaryKey, uniqKeys, foreignKeys
  , posKey

  -- * Utilities

  , runCommand

  -- * other stuffs

  , SessionMonad
  , Subrec
  )
 where

import           Control.Monad.Catch           (MonadCatch)
import           Control.Monad.IO.Class        (MonadIO)
import           Control.Monad.Trans.Reader    (ReaderT)
import           Data.Kind                     (Type)
import           Data.Proxy                    (Proxy (..))
import           Data.Singletons.Prelude
import           Data.Singletons.Prelude.List  ((:\\))
import           Data.Singletons.Prelude.Maybe (FromJust)
import           Data.Singletons.TH            (singletons)
import           Data.Tagged                   (Tagged)
import           Data.Text.Lazy                (Text)
import           Data.Type.Grec
import           GHC.Exts                      (Constraint)
import           GHC.Generics                  (Generic)
import           GHC.Prim                      (Proxy#, proxy#)
import           GHC.TypeLits                  (KnownSymbol, SomeSymbol (..),
                                                Symbol (..), symbolVal')
import           Perst.Types                   (AllIsNub, AllSubFst, BackTypes,
                                                CheckFK, FkIsNub, IsNub,
                                                IsSubFst, MandatoryFields,
                                                PosList, Submap, Subset)

singletons [d|
  data DeleteConstraint = DCCascade
                        | DCRestrict
                        | DCSetNull
      deriving (Show, Eq, Ord)
  |]

data DataDef
  = TableDef
    { rec :: Type
    , pk  :: [Symbol]
    , uk  :: [[Symbol]]
    , fk  :: [([(Symbol,Symbol)],(Symbol,DeleteConstraint))]
    }

class TableLike (a::k) where
  type TabName    (a :: k) :: Symbol
  type KeyDef     (a :: k) :: [Symbol]
  type RecordDef  (a :: k) :: [(Symbol,Type)]
  type Record     (a :: k) :: Type
  type UniqDef    (a :: k) :: [[Symbol]]
  -- | Foreign keys: [ [(referencing_field, referenced_field)], (table_name, RefType)]
  type FKDef      (a :: k) :: [([(Symbol,Symbol)],(Symbol,DeleteConstraint))]

instance TableLike  (TableDef r p u f :: DataDef) where
  type TabName    (TableDef r p u f) = Typ r
  type RecordDef  (TableDef r p u f) = Fields r
  type Record     (TableDef r p u f) = r
  type KeyDef     (TableDef r p u f) = p
  type UniqDef    (TableDef r p u f) = u
  type FKDef      (TableDef r p u f) = f

type FieldNames t = Map FstSym0 (RecordDef t)
type FieldNames' r = FieldNamesGrec r
type FieldTypes t = Map SndSym0 (RecordDef t)
type FieldTypes' r = FieldTypesGrec r

type PosKey t = PosList (KeyDef t) (FieldNames t)

type TableConstraint n r p u f
  = ( IsSubFst p r ~ True, AllSubFst u r ~ True, CheckFK f r ~ True
    , IsNub p ~ True, AllIsNub u ~ True, FkIsNub f ~ True
    )

type TabConstr (t :: DataDef) =
  ( TableLike t
  , TableConstraint (TabName t) (RecordDef t) (KeyDef t) (UniqDef t) (FKDef t)
  , KnownSymbol (TabName t)
  , SingI (FieldNames t)
  , SingI (KeyDef t)
  , SingI (UniqDef t)
  , SingI (FKDef t)
  )
type TabConstrB (b :: Type) (t::DataDef) =
  ( TabConstr t
  , DBOption b
  , SingI (BackTypes b NullableSym0 DbTypeNameSym0 (RecordDef t))
  )

type Mandatory t = MandatoryFields NullableSym0 (RecordDef t)

type RecConstr (b :: Type) (t :: DataDef) (r :: Type) =
  ( TabConstrB b t
  -- , ConvToGrec [FieldDB b] r
  , ConvFromGrec r [FieldDB b]
  -- inserted record is subrecord from table record
  , Submap (FieldNames' r) (RecordDef t) ~ Just (FieldTypes' r)
  , SingI (FieldNames' r)
  )

type InsConstr b t r =
  ( RecConstr b t r
  -- inserted record contains all mandatory fields
  , Subset (Mandatory t) (FieldNames' r) ~ True
  )

type InsAutoConstr b t r =
  ( RecConstr b t r
  , SingI (PosKey t)
  -- inserted record contains all mandatory fields except primary key
  , Subset (Mandatory t :\\ KeyDef t) (FieldNames' r) ~ True
  -- primary key is a single field with the same type as generated by backend
  , Submap (KeyDef t) (RecordDef t) ~ Just '[GenKey b]
  )

type Subrec t ns = Tagged ns (ListToPairs (FromJust (Submap ns (RecordDef t))))

type UpdByKeyConstr b t r (k :: Type) =
  ( RecConstr b t r
  , SingI (FieldNames' k)
  , ConvFromGrec k [FieldDB b]
  -- Perhaps we need Sort all keys to check it without counting of field's order
  -- but it can slow down compile time and profit is not obvious.
  -- I refuse it taking into account that we also can't make case insensitive comparing.
  -- So keys are both case and order sensitive.
  , Elem (FieldNames' k) ((KeyDef t) ': (UniqDef t)) ~ True
  )

type DelByKeyConstr b t (k :: Type) =
  ( TabConstrB b t
  , SingI (FieldNames' k)
  , ConvFromGrec k [FieldDB b]
  , Elem (FieldNames' k) ((KeyDef t) ': (UniqDef t)) ~ True
  )

type family Nullable a :: (Type, Bool) where
  Nullable (Maybe x) = x ::: True
  Nullable x = x ::: False
data NullableSym0 (l0 :: TyFun Type (Type, Bool) ) where
  NullableSym0KindInference ::
    forall (l0 :: TyFun Type (Type, Bool) ) (arg0 :: Type).
      KindOf (Apply NullableSym0 arg0) ~ KindOf (NullableSym1 arg0)
    => NullableSym0 l0
type instance Apply NullableSym0 l0 = NullableSym1 l0
type NullableSym1 a = Nullable a

tableName :: KnownSymbol (TabName t) => Proxy t -> String
tableName (_ :: Proxy t) = fromSing (sing :: Sing (TabName t))

fieldNames :: SingI (FieldNames t) => Proxy t -> [String]
fieldNames (_ :: Proxy t) = fromSing (sing :: Sing (FieldNames t))

fieldNames' :: SingI (FieldNames' r) => Proxy r -> [String]
fieldNames' (_ :: Proxy r) = fromSing (sing :: Sing (FieldNames' r))

dbTypeNames :: SingI (BackTypes b NullableSym0 DbTypeNameSym0 (RecordDef t))
            => Proxy (b :: Type) -> Proxy t -> [(String, Bool)]
dbTypeNames (_ :: Proxy b) (_ :: Proxy t)
  = fromSing (sing :: Sing (BackTypes b NullableSym0 DbTypeNameSym0 (RecordDef t)))

dbTypeNames' :: SingI (BackTypes b NullableSym0 DbTypeNameSym0 (Fields r))
            => Proxy (b :: Type) -> Proxy r -> [(String, Bool)]
dbTypeNames' (_ :: Proxy b) (_ :: Proxy r)
  = fromSing (sing :: Sing (BackTypes b NullableSym0 DbTypeNameSym0 (Fields r)))

primaryKey :: SingI (KeyDef t) => Proxy t -> [String]
primaryKey (_ :: Proxy t) = getSymbols (Proxy :: Proxy (KeyDef t))

posKey :: SingI (PosKey t) => Proxy t -> Maybe [Integer]
posKey (_ :: Proxy t) = fromSing (sing :: Sing (PosKey t))

uniqKeys :: SingI (UniqDef t) => Proxy t -> [[String]]
uniqKeys (_ :: Proxy t) = fromSing (sing :: Sing (UniqDef t))

getSymbols  :: SingI k => Proxy (k::[Symbol]) -> [String]
getSymbols (_ :: Proxy k) = fromSing (sing :: Sing k)

foreignKeys :: SingI (FKDef t)
            => Proxy t -> [([(String, String)], (String, DeleteConstraint))]
foreignKeys (_ :: Proxy t) = fromSing (sing :: Sing (FKDef t))

-- | Options for backend
class DBOption (back :: Type) where
  type FieldDB back       :: Type
  type Conn back          :: Type
  type SessionParams back :: Type
  type PrepCmd back       :: Type
  type GenKey back        :: Type -- set to () if generation is impossible
  paramName :: Proxy back -> Int -> Text -- ^ How to create param name (like "?1") from param num

  afterCreateTableText :: Proxy back -> Text
  afterCreateTableText _ = ""

  deleteConstraintText :: Proxy back -> DeleteConstraint -> Text
  deleteConstraintText _ DCRestrict = "ON DELETE RESTRICT"
  deleteConstraintText _ DCCascade  = "ON DELETE CASCADE"
  deleteConstraintText _ DCSetNull  = "ON DELETE SET NULL"

  runSession :: (MonadIO m, MonadCatch m)
          => Proxy back -> SessionParams back -> SessionMonad back m a -> m a
  prepareCommand :: MonadIO m => Text -> SessionMonad back m (PrepCmd back)
  -- | Executed before runPrepared in insertAuto operation.
  --   We can get there new key and put it into monad.
  preRunInAuto :: MonadIO m => SessionMonad back m ()
  runPrepared :: MonadIO m
              => PrepCmd back -> [FieldDB back] -> SessionMonad back m ()
  finalizePrepared :: MonadIO m => PrepCmd back -> SessionMonad back m ()
  getLastKey :: MonadIO m => SessionMonad back m (GenKey back)
  execCommand :: MonadIO m => Text -> SessionMonad back m ()

runCommand :: (DBOption back, MonadIO m)
            => Text -> [FieldDB back] -> SessionMonad back m ()
runCommand sql pars = do
  cmd <- prepareCommand sql
  runPrepared cmd pars


type family DbTypeName (b::Type) (a::Type) :: Symbol
data DbTypeNameSym0 (l0 :: TyFun Type (TyFun Type Symbol -> Type)) where
  DbTypeNameSym0KindInference ::
    forall (l0 :: TyFun Type (TyFun Type Symbol -> Type)) (arg0 :: Type).
      KindOf (Apply DbTypeNameSym0 arg0) ~ KindOf (DbTypeNameSym1 arg0)
    => DbTypeNameSym0 l0
type instance Apply DbTypeNameSym0 l0 = DbTypeNameSym1 l0
data DbTypeNameSym1 (l0 :: Type) (l1 :: TyFun Type Symbol) where
  DbTypeNameSym1KindInference ::
    forall (l0 :: Type) (l1 :: TyFun Type Symbol) (arg0 :: Type).
      KindOf (Apply (DbTypeNameSym1 l0) arg0) ~ KindOf (DbTypeNameSym2 l0 arg0)
    => DbTypeNameSym1 l0 l1
type instance Apply (DbTypeNameSym1 l0) l1 = DbTypeNameSym2 l0 l1
type DbTypeNameSym2 a b = DbTypeName a b

type SessionMonad b m = ReaderT (Proxy b, Conn b) m
