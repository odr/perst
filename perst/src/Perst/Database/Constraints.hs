{-# LANGUAGE TypeInType           #-}
{-# LANGUAGE UndecidableInstances #-}
module Perst.Database.Constraints
    (
    -- * Constraints required for DDL and DML operations

      RecConstr
    , DDLConstr
    , InsConstr, InsAutoConstr
    , UpdConstr, UpdByKeyConstr
    , DelConstr, DelByKeyConstr
    , SelConstr
    -- , ddProxy

    ) where

import           Data.Kind                    (Constraint, Type)
import           Data.Singletons.Prelude
import           Data.Singletons.Prelude.List ((:\\))
import           Data.Type.Grec               (ConvFromGrec, ConvToGrec,
                                               FieldNamesGrec, FieldTypesGrec)
import           GHC.TypeLits                 (KnownSymbol, SomeSymbol (..),
                                               Symbol (..), symbolVal')
import           Perst.Database.DataDef
import           Perst.Database.DbOption      (DbOption (..), DbOptionConstr,
                                               DbTypeNameSym0, NullableSym0)
import           Perst.Types                  (AllIsNub, AllIsSub, BackTypes,
                                               CheckFK, FkIsNub, IsNub, IsSub,
                                               MandatoryFields, PosList, Submap)

-- type IsCheck = 'True

type DDLConstr (b :: Type) (t::DataDef) =
  ( DbOptionConstr b t
  , IsProj t ~ False
  )

type Mandatory rd = MandatoryFields NullableSym0 rd

type RecConstr (b :: Type) (t :: DataDef) (r :: Type) =
  ( DbOptionConstr b t
  , RecConstr' t (FieldNamesGrec r) (FieldTypesGrec r)
  )

type family RecConstr' t fnr ftr where
  RecConstr' t fnr ftr =
    ( Submap fnr (DdRec t) ~ Just ftr
    , SingI fnr
    )

type InsConstr b t r =
  ( DbOptionConstr b t
  , InsConstr' t (FieldNamesGrec r) (FieldTypesGrec r)
  , ConvFromGrec r [FieldDB b]
  , If (IsProj t)
      (IsSub (Mandatory (DdRec (DdData t))) (DdFlds t) ~ True)
      (()::Constraint)
  )
type family InsConstr' t fnr ftr where
  InsConstr' t fnr ftr =
    ( RecConstr' t fnr ftr
    , IsSub fnr (DdUpd t) ~ True
    -- inserted record contains all mandatory fields
    , IsSub (Mandatory (DdRec t)) fnr ~ True
    )

type InsAutoConstr b t r =
  ( DbOptionConstr b t
  , InsAutoConstr' b t (FieldNamesGrec r) (FieldTypesGrec r)
  , ConvFromGrec r [FieldDB b]
  , If (IsProj t)
      (IsSub (Mandatory (DdRec (DdData t))) (DdFlds t) ~ True)
      (()::Constraint)
  )

type family InsAutoConstr' b t fnr ftr where
  InsAutoConstr' b t fnr ftr =
    ( RecConstr' t fnr ftr
    , IsSub fnr (DdUpd t) ~ True
    -- inserted record contains all mandatory fields except primary key
    , IsSub (Mandatory (DdRec t) :\\ DdKey t) fnr ~ True
    -- primary key is a single field with the same type as generated by backend
    , Submap (DdKey t) (DdRec t) ~ Just '[GenKey b]
    )

type UpdConstr b t r k =
  ( RecConstr b t r
  , UpdConstr' t (FieldNamesGrec r) (FieldTypesGrec r)
                 (FieldNamesGrec k) (FieldTypesGrec k)
  , ConvFromGrec r [FieldDB b]
  , ConvFromGrec k [FieldDB b]
  )
type family UpdConstr' t fnr ftr fnk ftk where
  UpdConstr' t fnr ftr fnk ftk =
    ( IsSub fnr (DdUpd t) ~ True
    , Submap fnk (DdRec t) ~ Just ftk
    , SingI fnk
    )

type UpdByKeyConstr b t r (k :: Type) =
  ( UpdConstr b t r k
  , Elem (FieldNamesGrec k) (AllKeys t) ~ True
  )

type DelConstr b t k =
  ( RecConstr b t k
  , ConvFromGrec k [FieldDB b]
  )

type DelByKeyConstr b t (k :: Type) =
  ( DelConstr b t k
  , Elem (FieldNamesGrec k) (AllKeys t) ~ True
  )

type SelConstr b t r (k :: Type) =
  ( RecConstr b t r
  , ConvToGrec [FieldDB b] r
  , ConvFromGrec k [FieldDB b]
  , RecConstr' t (FieldNamesGrec k) (FieldTypesGrec k)
  )

-- type CheckIf (a :: Bool) (b :: Constraint) = If a b (() :: Constraint)
