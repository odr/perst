{-# LANGUAGE TypeInType #-}
module Perst.Database.Constraints
    (
    -- * Constraints required for DDL and DML operations

      TableConstraint, TabConstr
    , TableConstraintB, TabConstrB
    , RecConstr
    , DDLConstr
    , InsConstr, InsAutoConstr
    , UpdConstr, UpdByKeyConstr
    , DelConstr, DelByKeyConstr
    , SelConstr
    , ddProxy

    ) where

import           Data.Kind                    (Constraint, Type)
import           Data.Singletons.Prelude
import           Data.Singletons.Prelude.List ((:\\))
import           Data.Type.Grec               (ConvFromGrec, ConvToGrec,
                                               FieldNamesGrec, FieldTypesGrec)
import           GHC.TypeLits                 (KnownSymbol, SomeSymbol (..),
                                               Symbol (..), symbolVal')
import           Perst.Database.Types
import           Perst.Types                  (AllIsNub, AllIsSub, BackTypes,
                                               CheckFK, FkIsNub, IsNub, IsSub,
                                               MandatoryFields, PosList, Submap)

type IsCheck = 'True


type TableConstraint t fn p u f
  = ( SingI fn, SingI p, SingI u, SingI f
    , KnownSymbol (DdName t)
    )

type TableConstraintB b t rd p u f =
  ( DBOption b
  , TableConstraint t (Map FstSym0 rd) p u f
  , SingI (BackTypes b NullableSym0 DbTypeNameSym0 rd)
  )

type DDLConstraint b t rd fn p u f =
  ( TableConstraintB b t rd p u f
  , CheckIf IsCheck
    ( CheckFK f fn ~ True
    , IsNub p ~ True
    , AllIsNub u ~ True
    , FkIsNub f ~ True
    , IsSub p fn ~ True
    , AllIsSub u fn ~ True
    )
  )

type RecordConstraint b t rd p u f fnr ftr =
  ( TableConstraintB b t rd p u f
  -- record is subrecord from table record
  , CheckIf IsCheck (Submap fnr rd ~ Just ftr)
  , SingI fnr
  )

type InsertConstraint b t rd upd p u f fnr ftr =
  ( RecordConstraint b t rd p u f fnr ftr
  , CheckIf IsCheck
    ( IsSub fnr upd ~ True
    -- inserted record contains all mandatory fields
    , IsSub (Mandatory rd) fnr ~ True
    )
  )

type InsertAutoConstraint b t rd upd p u f fnr ftr =
  ( RecordConstraint b t rd p u f fnr ftr
  , CheckIf IsCheck
    ( IsSub fnr upd ~ True
    -- inserted record contains all mandatory fields except primary key
    , IsSub (Mandatory rd :\\ p) fnr ~ True
    -- primary key is a single field with the same type as generated by backend
    , Submap p rd ~ Just '[GenKey b]
    )
  )

type SelectConstraint b t rd p u f fnr ftr fnk ftk =
  ( RecordConstraint b t rd p u f fnr ftr
  -- key is subrecord from table record
  , CheckIf IsCheck (Submap fnk rd ~ Just ftk)
  , SingI fnk
  )

type UpdateConstraint b t rd upd p u f fnr ftr fnk ftk =
  ( SelectConstraint b t rd p u f fnr ftr fnk ftk
  , CheckIf IsCheck (IsSub fnr upd ~ True)
  )

type UpdateByKeyConstraint b t rd upd p u f fnr ftr fnk ftk =
  ( UpdateConstraint b t rd upd p u f fnr ftr fnk ftk
  -- Perhaps we need Sort all keys to check it without counting of field's order
  -- but it can slow down compile time and profit is not obvious.
  -- I refuse it taking into account that we also can't make case insensitive comparing.
  -- So keys are both case and order sensitive.
  , CheckIf IsCheck (Elem fnk (p ': u) ~ True)
  )

type DeleteByKeyConstraint b t rd p u f fnk ftk =
  ( RecordConstraint b t rd p u f fnk ftk
  , CheckIf IsCheck (Elem fnk (p ': u) ~ True)
  )

type TabConstr (t :: DataDef) =
  ( TableConstraint t (FieldNames t) (DdKey t) (DdUniq t) (DdFrgn t)
  )
ddProxy :: TabConstr t => Proxy t -> Proxy t
ddProxy = id

type TabConstrB (b :: Type) (t::DataDef) =
  ( TableConstraintB b t (DdRec t) (DdKey t) (DdUniq t) (DdFrgn t)
  )

type DDLConstr' b t rd p u f =
  ( DDLConstraint b t rd (Map FstSym0 rd) p u f
  )

type DDLConstr (b :: Type) (t::DataDef) =
  ( DDLConstr' b t (DdRec t) (DdKey t) (DdUniq t) (DdFrgn t)
  )

type Mandatory rd = MandatoryFields NullableSym0 rd

type RecConstr (b :: Type) (t :: DataDef) (r :: Type) =
  ( RecordConstraint b t (DdRec t) (DdKey t) (DdUniq t)
                      (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
  )

type InsConstr b t r =
  ( InsertConstraint b t (DdRec t) (DdUpd t) (DdKey t) (DdUniq t)
                      (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
  , ConvFromGrec r [FieldDB b]
  )

type InsAutoConstr b t r =
  ( InsertAutoConstraint b t (DdRec t) (DdUpd t) (DdKey t) (DdUniq t)
                      (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
  , ConvFromGrec r [FieldDB b]
  )

type UpdConstr b t r k =
  ( UpdateConstraint b t (DdRec t) (DdUpd t) (DdKey t) (DdUniq t)
                      (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
                      (FieldNamesGrec k) (FieldTypesGrec k)
  , ConvFromGrec r [FieldDB b]
  , ConvFromGrec k [FieldDB b]
  )

type UpdByKeyConstr b t r (k :: Type) =
  ( UpdateByKeyConstraint b t (DdRec t) (DdUpd t) (DdKey t) (DdUniq t)
                          (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
                          (FieldNamesGrec k) (FieldTypesGrec k)
  , ConvFromGrec r [FieldDB b]
  , ConvFromGrec k [FieldDB b]
  )

type DelConstr b t k =
  ( RecConstr b t k
  , ConvFromGrec k [FieldDB b]
  )

type DelByKeyConstr b t (k :: Type) =
  ( DeleteByKeyConstraint b t (DdRec t) (DdKey t) (DdUniq t)
                          (DdFrgn t) (FieldNamesGrec k) (FieldTypesGrec k)
  , ConvFromGrec k [FieldDB b]
  )

type SelConstr b t r (k :: Type) =
  ( SelectConstraint b t (DdRec t) (DdKey t) (DdUniq t)
                      (DdFrgn t) (FieldNamesGrec r) (FieldTypesGrec r)
                      (FieldNamesGrec k) (FieldTypesGrec k)
  , ConvToGrec [FieldDB b] r
  , ConvFromGrec k [FieldDB b]
  )

type CheckIf (a :: Bool) (b :: Constraint) = If a b (() :: Constraint)
-- type family CheckIf (a :: Bool) (b :: Constraint) :: Constraint where
--   CheckIf IsCheck False b = ()
--   CheckIf IsCheck True b  = b
