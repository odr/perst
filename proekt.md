# Проект системы Perst

## Назначение

Perst \(PERSistent on Types\) - фреймворк для трехуровневых приложений.

Реализует принцип: то, что известно во время разработки должно отражаться в типах и проверяться в compile-time.

3 уровня - БД, сервер приложений, клиент. В идеале, все уровни должны описываться в одном месте \(на Haskell, с контролем типов\).

## Базовые типы данных

Типы данных, хранимые в БД и отображаемые в браузере описываются обычными Haskell-records с одним конструктором и именованными полями.

Чтобы получить необходимую гибкость, типы должны принадлежать классу Generic. Используя интерфейс класса Generic, на уровне типов данных, в соответствие типу записи ставится тип `Tagged t p,` где

* t - двоичное дерево. В листьях дерева - имена полей \(типы вида Symbol\). В узлах - значения вида \(Maybe Symbol\), означающие префикс для названий соответствующих поддеревьев.  
  Чтобы получить полное имя для листа дерева надо подняться по дереву, пока узлы имеют название \(Just name\). Затем эти названия "склеить" сверху вниз.

* Тип p - двоичное дерево-значение \(вид Type\). Представляет собой пару, элементы которой либо поддеревья либо значения какого-то типа.  
  Таким образом, значения хранятся только в листьях дерева.  
  Структура дерева соответствует структуре дерева t.

Каждый Generic-тип с одним конструктором может быть преобразован к типу `Tagged t p` и обратно. Причем структура деревьев `t` и `p` будет соответствовать структуре Generic - представления типа.

При преобразовании записи в тип Tagged t p, специальным случаем являются поля типа `Tagged (s :: Maybe Symbol) v`. Эти поля рассматриваются как подгруппы полей с префиксом имен `s`.

Тип `Tagged t p` позволяет легко добавлять к нему новые поля и удалять имеющиеся.

К типу `Tagged t p` нетрудно привести и типы `Tagged '[n1,n2,...nk] (a1,a2,...,ak)`\(с несбалансированным деревом\).

### Доступ к полям по имени

Для типа `Tagged t p` реализуются линзы на основе имен полей:

```Haskell
class TLens s b a where
  type LType s b
  type RType s b a
  tlens :: Functor f -> (LType s b -> f a) -> b -> f (RType s b a)
```

что позволяет получить

```Haskell
> :set -XTypeApplications
> :t tlens @"x" 
tlens @"x" :: (a -> f a) -> b -> f b
```

Если дерево уравновешено, то оценка сложности доступа к полю по имени - O \(logN\), где N - количество полей.

### Последовательный доступ

## Взаимодействие с базой данных

## Клиентская часть



